<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room Controller - Admin</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
      min-height: 100vh;
    }

    h1 {
      color: #00d4ff;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    h2 {
      color: #888;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 30px 0 15px;
      border-bottom: 1px solid #333;
      padding-bottom: 5px;
    }

    .status-badge {
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 12px;
      background: #2a5;
      color: white;
    }

    .status-badge.offline {
      background: #a52;
    }

    .card {
      background: #252540;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .card-title {
      font-weight: 600;
      color: #fff;
    }

    .card-subtitle {
      font-size: 12px;
      color: #888;
      font-family: monospace;
    }

    .prop-status {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #555;
    }

    .dot.online { background: #2a5; }
    .dot.solved { background: #fa0; }

    .sensors-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }

    .sensor-tag {
      font-size: 11px;
      padding: 3px 8px;
      background: #333;
      border-radius: 4px;
      color: #aaa;
    }

    .sensor-tag.triggered {
      background: #2a5;
      color: white;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      transition: opacity 0.2s;
    }

    button:hover {
      opacity: 0.8;
    }

    .btn-primary {
      background: #00d4ff;
      color: #000;
    }

    .btn-secondary {
      background: #444;
      color: #fff;
    }

    .btn-danger {
      background: #a52;
      color: #fff;
    }

    .btn-small {
      padding: 4px 10px;
      font-size: 11px;
    }

    input, select {
      padding: 8px 12px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 14px;
      width: 100%;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #00d4ff;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      color: #888;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #252540;
      border-radius: 12px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal h3 {
      margin-bottom: 20px;
      color: #00d4ff;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      border-radius: 8px;
      background: #2a5;
      color: white;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s;
      z-index: 200;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .toast.error {
      background: #a52;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #333;
    }

    .info-label {
      color: #888;
    }

    .info-value {
      font-family: monospace;
    }

    .restart-warning {
      background: #fa03;
      color: #fa0;
      padding: 10px 15px;
      border-radius: 6px;
      margin-top: 20px;
      display: none;
      align-items: center;
      gap: 10px;
    }

    .restart-warning.show {
      display: flex;
    }

    .empty-state {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .sensor-editor {
      background: #1a1a2e;
      border-radius: 6px;
      padding: 12px;
      margin-top: 8px;
    }

    .sensor-row {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 8px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #333;
    }

    .sensor-row:last-child {
      border-bottom: none;
    }

    .sensor-row input {
      padding: 6px 10px;
      font-size: 13px;
    }

    .sensor-row .btn-icon {
      width: 32px;
      height: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      border-radius: 4px;
    }

    .sensor-header {
      display: grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 8px;
      font-size: 11px;
      color: #666;
      padding-bottom: 6px;
      border-bottom: 1px solid #444;
      margin-bottom: 4px;
    }

    .prop-type-badge {
      font-size: 11px;
      padding: 3px 8px;
      background: #00d4ff33;
      color: #00d4ff;
      border-radius: 4px;
      margin-left: 8px;
    }

    .add-sensor-btn {
      width: 100%;
      margin-top: 10px;
      padding: 8px;
      background: #333;
      border: 1px dashed #555;
      color: #888;
      font-size: 12px;
    }

    .add-sensor-btn:hover {
      background: #3a3a5a;
      border-color: #00d4ff;
      color: #00d4ff;
    }

    .no-sensors {
      text-align: center;
      color: #666;
      font-size: 12px;
      padding: 15px;
    }

    .type-selector {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .type-selector select {
      flex: 1;
      max-width: 250px;
    }

    .type-selector .type-actions {
      display: flex;
      gap: 4px;
    }

    .empty-types {
      color: #666;
      font-size: 13px;
      padding: 10px 0;
    }

    /* Step Groups for Props */
    .step-group {
      background: #1e1e35;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 8px;
      border: 2px solid transparent;
      transition: border-color 0.2s, background 0.2s;
      position: relative;
    }

    .step-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .step-header .step-number {
      background: #00d4ff33;
      color: #00d4ff;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 600;
    }

    .step-props {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .step-props .card {
      flex: 1;
      min-width: 280px;
      margin-bottom: 0;
      cursor: grab;
      transition: transform 0.2s, box-shadow 0.2s, opacity 0.2s;
    }

    .step-props .card:active {
      cursor: grabbing;
    }

    .step-props .card.dragging {
      opacity: 0.5;
      transform: scale(0.98);
    }

    .step-props .card .drag-handle {
      color: #555;
      margin-right: 8px;
      cursor: grab;
    }

    /* Drop Zones */
    .drop-zone {
      height: 4px;
      margin: 4px 0;
      border-radius: 2px;
      background: transparent;
      transition: all 0.2s;
    }

    .drop-zone.drag-over {
      height: 40px;
      background: #00d4ff33;
      border: 2px dashed #00d4ff;
      margin: 8px 0;
    }

    .drop-zone.drag-over::after {
      content: 'Nouvelle étape';
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #00d4ff;
      font-size: 12px;
    }

    /* Parallel drop indicator */
    .parallel-indicator {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fa0;
      color: #000;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      white-space: nowrap;
    }

    .step-group.drag-over-parallel .parallel-indicator {
      display: block;
    }

    /* New step indicator (when hovering top/bottom of step) */
    .new-step-indicator {
      display: none;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      background: #00d4ff;
      color: #000;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      white-space: nowrap;
    }

    .step-group.drag-over-newstep-after {
      border-bottom: 3px solid #00d4ff;
    }

    .step-group.drag-over-newstep-before {
      border-top: 3px solid #00d4ff;
    }

    .step-group.drag-over-newstep-after .new-step-indicator,
    .step-group.drag-over-newstep-before .new-step-indicator {
      display: block;
    }

    .step-group.drag-over-newstep-after .new-step-indicator {
      bottom: -16px;
      top: auto;
    }

    .step-group.drag-over-newstep-before .new-step-indicator {
      top: -16px;
      bottom: auto;
    }

    .step-group.drag-over-newstep-after .parallel-indicator,
    .step-group.drag-over-newstep-before .parallel-indicator {
      display: none;
    }

    /* Highlight the step group when dragging over */
    .step-group.drag-over-parallel {
      background: #2a2a45;
      border-color: #fa0;
    }

    /* Hide separate drop zones - we use card zones instead */
    .drop-zone {
      display: none;
    }

    .step-props .card {
      position: relative;
    }

    .parallel-badge {
      font-size: 11px;
      color: #fa0;
      background: #fa01a;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .drag-handle {
      color: #555;
      margin-right: 8px;
      cursor: grab;
      user-select: none;
    }

    .card[draggable="true"]:hover .drag-handle {
      color: #00d4ff;
    }
  </style>
</head>
<body>
  <h1>
    <span>Room Controller</span>
    <span class="status-badge" id="connectionStatus">Chargement...</span>
  </h1>

  <div class="restart-warning" id="restartWarning">
    <span>Configuration modifiee.</span>
    <button class="btn-primary btn-small" onclick="reloadConfig()">Appliquer</button>
    <button class="btn-secondary btn-small" onclick="location.reload()">Rafraichir</button>
  </div>

  <!-- Room Info -->
  <h2>Salle</h2>
  <div class="card">
    <div class="info-row">
      <span class="info-label">ID</span>
      <span class="info-value" id="roomId">-</span>
    </div>
    <div class="info-row">
      <span class="info-label">Nom</span>
      <span class="info-value" id="roomName">-</span>
    </div>
    <div class="info-row">
      <span class="info-label">Site</span>
      <span class="info-value" id="roomSite">-</span>
    </div>
    <div class="actions">
      <button class="btn-secondary btn-small" onclick="openEditRoomModal()">Modifier</button>
    </div>
  </div>

  <!-- MQTT Settings -->
  <h2>MQTT</h2>
  <div class="card">
    <div class="info-row">
      <span class="info-label">Broker</span>
      <span class="info-value" id="mqttBroker">-</span>
    </div>
    <div class="info-row">
      <span class="info-label">Base Topic</span>
      <span class="info-value" id="mqttBaseTopic">-</span>
    </div>
    <div class="actions">
      <button class="btn-secondary btn-small" onclick="openEditMqttModal()">Modifier</button>
    </div>
  </div>

  <!-- Sensor Types -->
  <h2>Types de Capteurs</h2>
  <div class="card">
    <div class="type-selector">
      <select id="sensorTypesDropdown" onchange="onSensorTypeSelected()">
        <option value="">-- Selectionner pour modifier --</option>
      </select>
      <div class="type-actions">
        <button class="btn-secondary btn-small" onclick="editSelectedSensorType()" id="editTypeBtn" disabled>Modifier</button>
        <button class="btn-danger btn-small" onclick="deleteSelectedSensorType()" id="deleteTypeBtn" disabled>Supprimer</button>
      </div>
    </div>
    <div class="actions">
      <button class="btn-secondary btn-small" onclick="openAddSensorTypeModal()">+ Ajouter un type</button>
    </div>
  </div>

  <!-- Props -->
  <h2>Props</h2>
  <div id="propsList"></div>
  <button class="btn-primary" onclick="openAddPropModal()" style="margin-top: 10px;">+ Ajouter un Prop</button>

  <!-- Export / Import -->
  <h2>Export / Import</h2>
  <div class="card">
    <p style="color: #aaa; font-size: 13px; margin-bottom: 12px;">
      Exporter la configuration et les medias de cette salle pour les importer sur un autre Room Controller.
      Les parametres reseau (MQTT, ports) sont exclus de l'export.
    </p>
    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
      <button class="btn-primary btn-small" onclick="exportRoom()">Exporter la salle</button>
      <label style="font-size: 13px; color: #aaa; display: flex; align-items: center; gap: 6px;">
        <input type="checkbox" id="exportHistory"> Inclure l'historique des sessions
      </label>
    </div>
    <hr style="border-color: #333; margin: 12px 0;">
    <p style="color: #fa0; font-size: 12px; margin-bottom: 8px;">
      L'import remplacera toute la configuration et les medias actuels.
    </p>
    <div style="display: flex; align-items: center; gap: 12px;">
      <input type="file" id="importFile" accept=".zip" style="width: auto; font-size: 12px;">
      <button class="btn-secondary btn-small" onclick="importRoom()" id="importBtn">Importer</button>
    </div>
    <div id="importProgress" style="display: none; margin-top: 10px; color: #00d4ff; font-size: 13px;">
      Import en cours...
    </div>
  </div>

  <!-- Statistiques -->
  <h2>Statistiques</h2>
  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 15px;">
    <div class="card" style="text-align: center; padding: 15px;">
      <div style="font-size: 28px; font-weight: bold; color: #00d4ff;" id="statTotal">-</div>
      <div style="font-size: 12px; color: #888;">Sessions</div>
    </div>
    <div class="card" style="text-align: center; padding: 15px;">
      <div style="font-size: 28px; font-weight: bold; color: #22c55e;" id="statWinRate">-</div>
      <div style="font-size: 12px; color: #888;">Victoires</div>
    </div>
    <div class="card" style="text-align: center; padding: 15px;">
      <div style="font-size: 28px; font-weight: bold; color: #f59e0b;" id="statAvgTime">-</div>
      <div style="font-size: 12px; color: #888;">Temps moyen</div>
    </div>
    <div class="card" style="text-align: center; padding: 15px;">
      <div style="font-size: 28px; font-weight: bold; color: #a78bfa;" id="statAvgHints">-</div>
      <div style="font-size: 12px; color: #888;">Indices moy.</div>
    </div>
  </div>

  <div class="card" id="propStatsCard" style="display: none; margin-bottom: 15px;">
    <h3 style="margin-bottom: 10px; font-size: 14px; color: #ccc;">Analytique par Enigme</h3>
    <div style="overflow-x: auto;">
      <table style="width: 100%; font-size: 13px; border-collapse: collapse;">
        <thead>
          <tr style="border-bottom: 1px solid #333; color: #888;">
            <th style="text-align: left; padding: 6px 8px;">Prop</th>
            <th style="text-align: center; padding: 6px 8px;">Resolution</th>
            <th style="text-align: center; padding: 6px 8px;">Override</th>
            <th style="text-align: center; padding: 6px 8px;">Temps moy.</th>
            <th style="text-align: center; padding: 6px 8px;">Min</th>
            <th style="text-align: center; padding: 6px 8px;">Max</th>
            <th style="text-align: center; padding: 6px 8px;">Sessions</th>
          </tr>
        </thead>
        <tbody id="propStatsBody"></tbody>
      </table>
    </div>
  </div>

  <div class="card" id="sessionListCard" style="display: none;">
    <h3 style="margin-bottom: 10px; font-size: 14px; color: #ccc;">Historique des sessions</h3>
    <div id="sessionListAdmin" style="max-height: 400px; overflow-y: auto;"></div>
  </div>

  <!-- Edit Room Modal -->
  <div class="modal-overlay" id="editRoomModal">
    <div class="modal">
      <h3>Modifier la Salle</h3>
      <form id="editRoomForm">
        <div class="form-group">
          <label>ID (identifiant unique)</label>
          <input type="text" id="editRoomId" required>
        </div>
        <div class="form-group">
          <label>Nom</label>
          <input type="text" id="editRoomName" required>
        </div>
        <div class="form-group">
          <label>Site</label>
          <input type="text" id="editRoomSite" value="default">
        </div>
        <div class="actions">
          <button type="submit" class="btn-primary">Enregistrer</button>
          <button type="button" class="btn-secondary" onclick="closeModal('editRoomModal')">Annuler</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Edit MQTT Modal -->
  <div class="modal-overlay" id="editMqttModal">
    <div class="modal">
      <h3>Parametres MQTT</h3>
      <form id="editMqttForm">
        <div class="form-group">
          <label>Broker URL</label>
          <input type="text" id="editMqttBroker" placeholder="mqtt://localhost:1883" required>
        </div>
        <div class="form-group">
          <label>Base Topic</label>
          <input type="text" id="editMqttBaseTopic" placeholder="ey/default/magie" required>
        </div>
        <div class="actions">
          <button type="submit" class="btn-primary">Enregistrer</button>
          <button type="button" class="btn-secondary" onclick="closeModal('editMqttModal')">Annuler</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Add/Edit Prop Modal -->
  <div class="modal-overlay" id="propModal">
    <div class="modal">
      <h3 id="propModalTitle">Ajouter un Prop</h3>
      <form id="propForm">
        <input type="hidden" id="propEditMode" value="add">
        <input type="hidden" id="propOriginalId">
        <div class="form-group">
          <label>Prop ID (unique)</label>
          <input type="text" id="propId" placeholder="magie_puzzle1" required>
        </div>
        <input type="hidden" id="propOrder" value="1">
        <div class="form-row">
          <div class="form-group">
            <label>Nom</label>
            <input type="text" id="propName" placeholder="Puzzle Magique" required>
          </div>
          <div class="form-group">
            <label>Type de capteur</label>
            <select id="propType">
              <option value="">-- Aucun --</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Capteurs</label>
          <div class="sensor-editor">
            <div class="sensor-header">
              <span>ID Capteur</span>
              <span>Label</span>
              <span></span>
            </div>
            <div id="sensorsList"></div>
            <button type="button" class="add-sensor-btn" onclick="addSensorRow()">+ Ajouter un capteur</button>
          </div>
        </div>
        <div class="actions">
          <button type="submit" class="btn-primary">Enregistrer</button>
          <button type="button" class="btn-secondary" onclick="closeModal('propModal')">Annuler</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Add/Edit Sensor Type Modal -->
  <div class="modal-overlay" id="sensorTypeModal">
    <div class="modal" style="max-width: 400px;">
      <h3 id="sensorTypeModalTitle">Ajouter un Type</h3>
      <form id="sensorTypeForm">
        <input type="hidden" id="sensorTypeEditMode" value="add">
        <input type="hidden" id="sensorTypeOriginalId">
        <div class="form-group">
          <label>ID (unique, sans espaces)</label>
          <input type="text" id="sensorTypeId" placeholder="ex: rfid, magnet, laser" required pattern="[a-z0-9_-]+">
        </div>
        <div class="form-group">
          <label>Label (affichage)</label>
          <input type="text" id="sensorTypeLabel" placeholder="ex: RFID, Aimant, Laser" required>
        </div>
        <div class="actions">
          <button type="submit" class="btn-primary">Enregistrer</button>
          <button type="button" class="btn-secondary" onclick="closeModal('sensorTypeModal')">Annuler</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Confirm Delete Modal -->
  <div class="modal-overlay" id="confirmModal">
    <div class="modal" style="max-width: 350px; text-align: center;">
      <h3 style="margin-bottom: 10px;">Confirmer la suppression</h3>
      <p id="confirmMessage" style="color: #aaa; margin-bottom: 20px;">Supprimer ce capteur ?</p>
      <div class="actions" style="justify-content: center;">
        <button type="button" class="btn-danger" id="confirmDeleteBtn" onclick="confirmDeleteSensor()">Supprimer</button>
        <button type="button" class="btn-secondary" onclick="closeModal('confirmModal')">Annuler</button>
      </div>
    </div>
  </div>

  <script>
    let config = null;
    let state = null;

    // ─────────────────────────────────────────────────────────
    // API Calls
    // ─────────────────────────────────────────────────────────

    async function fetchConfig() {
      const res = await fetch('/api/config');
      config = await res.json();
      renderConfig();
    }

    async function fetchState() {
      try {
        const res = await fetch('/api/state');
        state = await res.json();
        document.getElementById('connectionStatus').textContent = 'Connecte';
        document.getElementById('connectionStatus').classList.remove('offline');
        renderProps();
      } catch (err) {
        document.getElementById('connectionStatus').textContent = 'Deconnecte';
        document.getElementById('connectionStatus').classList.add('offline');
      }
    }

    // ─────────────────────────────────────────────────────────
    // Rendering
    // ─────────────────────────────────────────────────────────

    function renderConfig() {
      // Room info
      document.getElementById('roomId').textContent = config.room.id;
      document.getElementById('roomName').textContent = config.room.name;
      document.getElementById('roomSite').textContent = config.room.site || 'default';

      // MQTT
      document.getElementById('mqttBroker').textContent = config.mqtt.broker;
      document.getElementById('mqttBaseTopic').textContent = config.mqtt.baseTopic;

      renderSensorTypes();
      renderProps();
    }

    function renderSensorTypes() {
      const dropdown = document.getElementById('sensorTypesDropdown');
      const types = config.sensorTypes || [];

      dropdown.innerHTML = '<option value="">-- Selectionner pour modifier --</option>' +
        types.map(t => `<option value="${t.id}">${t.label}</option>`).join('');

      // Reset buttons state
      document.getElementById('editTypeBtn').disabled = true;
      document.getElementById('deleteTypeBtn').disabled = true;

      // Also update the prop type dropdown
      updatePropTypeDropdown();
    }

    function updatePropTypeDropdown(selectedType = '') {
      const dropdown = document.getElementById('propType');
      const types = config.sensorTypes || [];

      dropdown.innerHTML = '<option value="">-- Aucun --</option>' +
        types.map(t => `<option value="${t.id}" ${t.id === selectedType ? 'selected' : ''}>${t.label}</option>`).join('');
    }

    function onSensorTypeSelected() {
      const dropdown = document.getElementById('sensorTypesDropdown');
      const hasSelection = dropdown.value !== '';
      document.getElementById('editTypeBtn').disabled = !hasSelection;
      document.getElementById('deleteTypeBtn').disabled = !hasSelection;
    }

    function editSelectedSensorType() {
      const typeId = document.getElementById('sensorTypesDropdown').value;
      if (typeId) {
        openEditSensorTypeModal(typeId);
      }
    }

    function deleteSelectedSensorType() {
      const typeId = document.getElementById('sensorTypesDropdown').value;
      if (typeId) {
        deleteSensorType(typeId);
      }
    }

    function renderProps() {
      const container = document.getElementById('propsList');

      if (!config.props || config.props.length === 0) {
        container.innerHTML = '<div class="empty-state">Aucun prop configure</div>';
        return;
      }

      // Group props by order (step)
      const stepGroups = {};
      config.props.forEach(prop => {
        const order = prop.order || 1;
        if (!stepGroups[order]) {
          stepGroups[order] = [];
        }
        stepGroups[order].push(prop);
      });

      // Get sorted step numbers
      const stepNumbers = Object.keys(stepGroups).map(Number).sort((a, b) => a - b);

      let html = '';

      // Initial drop zone
      html += `<div class="drop-zone" data-target-step="0" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDropBetween(event, 0)"></div>`;

      stepNumbers.forEach((stepNum, stepIndex) => {
        const propsInStep = stepGroups[stepNum];
        const isParallel = propsInStep.length > 1;

        html += `
          <div class="step-group" data-step="${stepNum}" ondragover="handleStepDragOver(event)" ondragleave="handleStepDragLeave(event)" ondrop="handleDropOnStep(event, ${stepNum})">
            <div class="step-header">
              <span class="step-number">Etape ${stepIndex + 1}</span>
              ${isParallel ? '<span class="parallel-badge">' + propsInStep.length + ' props en parallele</span>' : ''}
            </div>
            <div class="step-props">
              ${propsInStep.map(prop => renderPropCard(prop)).join('')}
            </div>
            <div class="parallel-indicator">Ajouter en parallele</div>
            <div class="new-step-indicator">Nouvelle etape</div>
          </div>
        `;

        // Drop zone after each step group
        html += `<div class="drop-zone" data-target-step="${stepNum}" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDropBetween(event, ${stepNum})"></div>`;
      });

      container.innerHTML = html;
    }

    function renderPropCard(prop) {
      // Find runtime state for this prop
      const runtimeProp = state?.props?.find(p => p.propId === prop.propId);
      const isOnline = runtimeProp?.online || false;
      const isSolved = runtimeProp?.solved || false;

      // Type is now at prop level
      const propTypeLabel = getTypeLabel(prop.type);
      const propTypeBadge = propTypeLabel ? `<span class="prop-type-badge">${propTypeLabel}</span>` : '';

      const sensorsHtml = prop.sensors.map(s => {
        const triggered = runtimeProp?.sensors?.find(rs => rs.sensorId === s.sensorId)?.triggered;
        return `<span class="sensor-tag ${triggered ? 'triggered' : ''}">${s.label}</span>`;
      }).join('');

      return `
        <div class="card" draggable="true" data-prop-id="${prop.propId}" data-prop-order="${prop.order}"
             ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)">
          <div class="card-header">
            <div>
              <span class="drag-handle">⋮⋮</span>
              <span class="card-title">${prop.name}${propTypeBadge}</span>
              <div class="card-subtitle">${prop.propId}</div>
            </div>
            <div class="prop-status">
              <div class="dot ${isOnline ? 'online' : ''}" title="${isOnline ? 'En ligne' : 'Hors ligne'}"></div>
              <div class="dot ${isSolved ? 'solved' : ''}" title="${isSolved ? 'Resolu' : 'Non resolu'}"></div>
            </div>
          </div>
          <div class="sensors-list">${sensorsHtml || '<span style="color:#666;font-size:12px;">Aucun capteur</span>'}</div>
          <div class="actions">
            <button class="btn-secondary btn-small" onclick="openEditPropModal('${prop.propId}')">Modifier</button>
            <button class="btn-danger btn-small" onclick="deleteProp('${prop.propId}')">Supprimer</button>
          </div>
        </div>
      `;
    }

    // ─────────────────────────────────────────────────────────
    // Modals
    // ─────────────────────────────────────────────────────────

    function openModal(id) {
      document.getElementById(id).classList.add('active');
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('active');
    }

    function openEditRoomModal() {
      document.getElementById('editRoomId').value = config.room.id;
      document.getElementById('editRoomName').value = config.room.name;
      document.getElementById('editRoomSite').value = config.room.site || 'default';
      openModal('editRoomModal');
    }

    function openEditMqttModal() {
      document.getElementById('editMqttBroker').value = config.mqtt.broker;
      document.getElementById('editMqttBaseTopic').value = config.mqtt.baseTopic;
      openModal('editMqttModal');
    }

    function openAddPropModal() {
      document.getElementById('propModalTitle').textContent = 'Ajouter un Prop';
      document.getElementById('propEditMode').value = 'add';
      document.getElementById('propOriginalId').value = '';
      document.getElementById('propId').value = '';
      document.getElementById('propId').disabled = false;
      document.getElementById('propName').value = '';

      // Auto-assign next order (max existing order + 1)
      const maxOrder = config.props.length > 0
        ? Math.max(...config.props.map(p => p.order || 1))
        : 0;
      document.getElementById('propOrder').value = maxOrder + 1;

      // Update prop type dropdown
      updatePropTypeDropdown('');

      // Initialize with one empty sensor
      renderSensorsList([{ sensorId: '', label: '' }]);
      openModal('propModal');
    }

    function openEditPropModal(propId) {
      const prop = config.props.find(p => p.propId === propId);
      if (!prop) return;

      document.getElementById('propModalTitle').textContent = 'Modifier le Prop';
      document.getElementById('propEditMode').value = 'edit';
      document.getElementById('propOriginalId').value = propId;
      document.getElementById('propId').value = prop.propId;
      document.getElementById('propId').disabled = true;
      document.getElementById('propName').value = prop.name;
      document.getElementById('propOrder').value = prop.order; // Preserved but hidden, order changed via drag & drop

      // Update prop type dropdown with current value
      updatePropTypeDropdown(prop.type || '');

      // Populate sensors list (type is now at prop level)
      const sensors = prop.sensors.map(s => ({
        sensorId: s.sensorId,
        label: s.label || ''
      }));
      renderSensorsList(sensors.length > 0 ? sensors : [{ sensorId: '', label: '' }]);
      openModal('propModal');
    }

    function openAddSensorTypeModal() {
      document.getElementById('sensorTypeModalTitle').textContent = 'Ajouter un Type';
      document.getElementById('sensorTypeEditMode').value = 'add';
      document.getElementById('sensorTypeOriginalId').value = '';
      document.getElementById('sensorTypeId').value = '';
      document.getElementById('sensorTypeId').disabled = false;
      document.getElementById('sensorTypeLabel').value = '';
      openModal('sensorTypeModal');
    }

    function openEditSensorTypeModal(typeId) {
      const sensorType = (config.sensorTypes || []).find(t => t.id === typeId);
      if (!sensorType) return;

      document.getElementById('sensorTypeModalTitle').textContent = 'Modifier le Type';
      document.getElementById('sensorTypeEditMode').value = 'edit';
      document.getElementById('sensorTypeOriginalId').value = typeId;
      document.getElementById('sensorTypeId').value = sensorType.id;
      document.getElementById('sensorTypeId').disabled = true;
      document.getElementById('sensorTypeLabel').value = sensorType.label;
      openModal('sensorTypeModal');
    }

    // ─────────────────────────────────────────────────────────
    // Sensor Editor
    // ─────────────────────────────────────────────────────────

    function renderSensorsList(sensors) {
      const container = document.getElementById('sensorsList');

      if (!sensors || sensors.length === 0) {
        container.innerHTML = '<div class="no-sensors">Aucun capteur</div>';
        return;
      }

      container.innerHTML = sensors.map((sensor, index) => `
        <div class="sensor-row" data-index="${index}">
          <input type="text"
                 class="sensor-id"
                 value="${sensor.sensorId || ''}"
                 placeholder="ex: sensor1, magnet1">
          <input type="text"
                 class="sensor-label"
                 value="${sensor.label || ''}"
                 placeholder="Description du capteur">
          <button type="button" class="btn-danger btn-icon" onclick="removeSensorRow(${index})" title="Supprimer">×</button>
        </div>
      `).join('');
    }

    function addSensorRow() {
      const sensors = collectSensorsFromUI();
      sensors.push({ sensorId: '', label: '' });
      renderSensorsList(sensors);

      // Focus the new sensor ID input
      const rows = document.querySelectorAll('.sensor-row');
      const lastRow = rows[rows.length - 1];
      if (lastRow) {
        lastRow.querySelector('.sensor-id').focus();
      }
    }

    let pendingDeleteSensorIndex = null;

    function removeSensorRow(index) {
      // Store the index and show confirmation modal
      pendingDeleteSensorIndex = index;
      const sensors = collectSensorsFromUI();
      const sensor = sensors[index];
      const sensorName = sensor?.label || sensor?.sensorId || `Capteur ${index + 1}`;
      document.getElementById('confirmMessage').textContent = `Supprimer "${sensorName}" ?`;
      openModal('confirmModal');
    }

    function confirmDeleteSensor() {
      if (pendingDeleteSensorIndex !== null) {
        const sensors = collectSensorsFromUI();
        sensors.splice(pendingDeleteSensorIndex, 1);
        renderSensorsList(sensors.length > 0 ? sensors : []);
        pendingDeleteSensorIndex = null;
      }
      closeModal('confirmModal');
    }

    function collectSensorsFromUI() {
      const rows = document.querySelectorAll('.sensor-row');
      const sensors = [];

      rows.forEach(row => {
        const sensorId = row.querySelector('.sensor-id').value.trim();
        const label = row.querySelector('.sensor-label').value.trim();

        // Only include if at least sensorId is filled
        if (sensorId) {
          sensors.push({
            sensorId,
            label: label || sensorId
          });
        }
      });

      return sensors;
    }

    // ─────────────────────────────────────────────────────────
    // Form Handlers
    // ─────────────────────────────────────────────────────────

    document.getElementById('editRoomForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      try {
        const res = await fetch('/api/config/room', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: document.getElementById('editRoomId').value,
            name: document.getElementById('editRoomName').value,
            site: document.getElementById('editRoomSite').value
          })
        });
        const data = await res.json();
        if (data.success) {
          showToast('Salle mise a jour');
          closeModal('editRoomModal');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    });

    document.getElementById('editMqttForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      try {
        const res = await fetch('/api/config/mqtt', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            broker: document.getElementById('editMqttBroker').value,
            baseTopic: document.getElementById('editMqttBaseTopic').value
          })
        });
        const data = await res.json();
        if (data.success) {
          showToast('MQTT mis a jour');
          closeModal('editMqttModal');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    });

    document.getElementById('propForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      // Collect sensors from UI
      const sensors = collectSensorsFromUI();

      const mode = document.getElementById('propEditMode').value;
      const propId = document.getElementById('propId').value.trim();
      const originalId = document.getElementById('propOriginalId').value;
      const propType = document.getElementById('propType').value;

      if (!propId) {
        showToast('L\'ID du prop est requis', true);
        return;
      }

      const body = {
        propId,
        name: document.getElementById('propName').value.trim(),
        type: propType,
        order: parseInt(document.getElementById('propOrder').value, 10),
        sensors
      };

      try {
        let res;
        if (mode === 'add') {
          res = await fetch('/api/config/props', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
        } else {
          res = await fetch(`/api/config/props/${originalId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
        }

        const data = await res.json();
        if (data.success) {
          showToast(mode === 'add' ? 'Prop ajoute' : 'Prop mis a jour');
          closeModal('propModal');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    });

    async function deleteProp(propId) {
      if (!confirm(`Supprimer le prop "${propId}" ?`)) return;

      try {
        const res = await fetch(`/api/config/props/${propId}`, { method: 'DELETE' });
        const data = await res.json();
        if (data.success) {
          showToast('Prop supprime');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    }

    // Sensor Type Form Handler
    document.getElementById('sensorTypeForm').addEventListener('submit', async (e) => {
      e.preventDefault();

      const mode = document.getElementById('sensorTypeEditMode').value;
      const id = document.getElementById('sensorTypeId').value.trim().toLowerCase();
      const originalId = document.getElementById('sensorTypeOriginalId').value;
      const label = document.getElementById('sensorTypeLabel').value.trim();

      if (!id || !label) {
        showToast('ID et label sont requis', true);
        return;
      }

      try {
        let res;
        if (mode === 'add') {
          res = await fetch('/api/config/sensor-types', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id, label })
          });
        } else {
          res = await fetch(`/api/config/sensor-types/${originalId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ label })
          });
        }

        const data = await res.json();
        if (data.success) {
          showToast(mode === 'add' ? 'Type ajoute' : 'Type mis a jour');
          closeModal('sensorTypeModal');
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    });

    async function deleteSensorType(typeId) {
      const typeLabel = getTypeLabel(typeId);
      if (!confirm(`Supprimer le type "${typeLabel}" ?`)) return;

      try {
        const res = await fetch(`/api/config/sensor-types/${typeId}`, { method: 'DELETE' });
        const data = await res.json();
        if (data.success) {
          showToast('Type supprime');
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    }

    // ─────────────────────────────────────────────────────────
    // Drag & Drop
    // ─────────────────────────────────────────────────────────

    let draggedPropId = null;
    let draggedPropOrder = null;

    function handleDragStart(event) {
      const card = event.target.closest('.card');
      if (!card) return;

      draggedPropId = card.dataset.propId;
      draggedPropOrder = parseInt(card.dataset.propOrder, 10);

      card.classList.add('dragging');
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.setData('text/plain', draggedPropId);
    }

    function handleDragEnd(event) {
      const card = event.target.closest('.card');
      if (card) {
        card.classList.remove('dragging');
      }
      draggedPropId = null;
      draggedPropOrder = null;

      // Remove all drag-over states
      document.querySelectorAll('.drop-zone').forEach(zone => zone.classList.remove('drag-over'));
      document.querySelectorAll('.step-group').forEach(group => {
        group.classList.remove('drag-over-parallel', 'drag-over-newstep-before', 'drag-over-newstep-after');
      });
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      event.target.classList.add('drag-over');
    }

    function handleDragLeave(event) {
      event.target.classList.remove('drag-over');
    }

    function handleStepDragOver(event) {
      event.preventDefault();
      const stepGroup = event.target.closest('.step-group');
      if (stepGroup) {
        const stepOrder = parseInt(stepGroup.dataset.step, 10);
        const rect = stepGroup.getBoundingClientRect();
        const mouseY = event.clientY;
        const topZoneEnd = rect.top + (rect.height * 0.25);
        const bottomZoneStart = rect.bottom - (rect.height * 0.25);

        // Remove all classes first
        stepGroup.classList.remove('drag-over-parallel', 'drag-over-newstep-before', 'drag-over-newstep-after');

        if (mouseY <= topZoneEnd) {
          // Top 25% - new step before
          stepGroup.classList.add('drag-over-newstep-before');
        } else if (mouseY >= bottomZoneStart) {
          // Bottom 25% - new step after
          stepGroup.classList.add('drag-over-newstep-after');
        } else if (stepOrder !== draggedPropOrder) {
          // Middle 50% - parallel (only if not same step)
          stepGroup.classList.add('drag-over-parallel');
        }
      }
      event.dataTransfer.dropEffect = 'move';
    }

    function handleStepDragLeave(event) {
      const stepGroup = event.target.closest('.step-group');
      if (stepGroup && !stepGroup.contains(event.relatedTarget)) {
        stepGroup.classList.remove('drag-over-parallel', 'drag-over-newstep-before', 'drag-over-newstep-after');
      }
    }

    // Drop between steps -> create new sequential step
    async function handleDropBetween(event, afterStepOrder) {
      event.preventDefault();
      event.target.classList.remove('drag-over');

      if (!draggedPropId) return;

      // Calculate new order: insert after afterStepOrder
      // Get all unique orders sorted
      const orders = [...new Set(config.props.map(p => p.order))].sort((a, b) => a - b);
      const afterIndex = orders.indexOf(afterStepOrder);

      let newOrder;
      if (afterStepOrder === 0) {
        // Dropped at the very beginning
        newOrder = orders.length > 0 ? orders[0] - 1 : 1;
        if (newOrder < 1) {
          // Need to shift all orders up
          await shiftOrdersAndMove(draggedPropId, 1, true);
          return;
        }
      } else {
        // Dropped after a step
        const nextOrder = orders[afterIndex + 1];
        if (nextOrder !== undefined) {
          // There's a step after, use a value between
          newOrder = afterStepOrder + 1;
          if (newOrder >= nextOrder) {
            // Need to shift orders to make room
            await shiftOrdersAndMove(draggedPropId, newOrder, true);
            return;
          }
        } else {
          // Dropped at the end
          newOrder = afterStepOrder + 1;
        }
      }

      await updatePropOrder(draggedPropId, newOrder);
    }

    // Drop on step -> add as parallel (middle) OR new step (top/bottom zones)
    async function handleDropOnStep(event, stepOrder) {
      event.preventDefault();
      const stepGroup = event.target.closest('.step-group');
      const isNewStepBefore = stepGroup?.classList.contains('drag-over-newstep-before');
      const isNewStepAfter = stepGroup?.classList.contains('drag-over-newstep-after');

      if (stepGroup) {
        stepGroup.classList.remove('drag-over-parallel', 'drag-over-newstep-before', 'drag-over-newstep-after');
      }

      if (!draggedPropId) return;

      if (isNewStepBefore) {
        // Top zone - create new step BEFORE this one
        const orders = [...new Set(config.props.map(p => p.order))].sort((a, b) => a - b);
        const stepIndex = orders.indexOf(stepOrder);
        const prevOrder = stepIndex > 0 ? orders[stepIndex - 1] : 0;
        await handleDropBetween(event, prevOrder);
      } else if (isNewStepAfter) {
        // Bottom zone - create new step AFTER this one
        await handleDropBetween(event, stepOrder);
      } else if (draggedPropOrder !== stepOrder) {
        // Middle zone - add as parallel (same order), only if different step
        await updatePropOrder(draggedPropId, stepOrder);
      }
    }

    async function updatePropOrder(propId, newOrder) {
      try {
        const res = await fetch(`/api/config/props/${propId}/order`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ order: newOrder })
        });
        const data = await res.json();
        if (data.success) {
          showToast('Ordre mis a jour');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    }

    async function shiftOrdersAndMove(propId, targetOrder, insertBefore = false) {
      try {
        const res = await fetch(`/api/config/props/reorder`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ propId, targetOrder, insertBefore })
        });
        const data = await res.json();
        if (data.success) {
          showToast('Ordre mis a jour');
          showRestartWarning();
          fetchConfig();
        } else {
          showToast(data.error, true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    }

    // ─────────────────────────────────────────────────────────
    // Utilities
    // ─────────────────────────────────────────────────────────

    function getTypeLabel(typeId) {
      if (!typeId) return '';
      const sensorType = (config.sensorTypes || []).find(t => t.id === typeId);
      return sensorType ? sensorType.label : typeId;
    }

    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.toggle('error', isError);
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3000);
    }

    function showRestartWarning() {
      document.getElementById('restartWarning').classList.add('show');
    }

    async function reloadConfig() {
      try {
        const res = await fetch('/api/reload', { method: 'POST' });
        const data = await res.json();
        if (data.success) {
          showToast('Configuration rechargee (' + data.props + ' props)');
          document.getElementById('restartWarning').classList.remove('show');
          fetchConfig();
          fetchState();
        } else {
          showToast(data.error || 'Erreur lors du rechargement', true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      }
    }

    // Close modals on backdrop click
    document.querySelectorAll('.modal-overlay').forEach(overlay => {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.classList.remove('active');
        }
      });
    });

    // ─────────────────────────────────────────────────────────
    // Export / Import
    // ─────────────────────────────────────────────────────────

    function exportRoom() {
      const includeHistory = document.getElementById('exportHistory').checked;
      const url = `/api/export${includeHistory ? '?history=true' : ''}`;
      // Trigger browser download
      window.location.href = url;
    }

    async function importRoom() {
      const fileInput = document.getElementById('importFile');
      const file = fileInput.files[0];
      if (!file) {
        showToast('Selectionnez un fichier .zip', true);
        return;
      }

      if (!confirm('L\'import va remplacer la configuration et les medias actuels. Continuer ?')) return;

      const progress = document.getElementById('importProgress');
      const btn = document.getElementById('importBtn');
      progress.style.display = 'block';
      btn.disabled = true;

      try {
        const formData = new FormData();
        formData.append('archive', file);

        const res = await fetch('/api/import', {
          method: 'POST',
          body: formData
        });
        const data = await res.json();

        if (data.success) {
          showToast(`Import termine (${data.props} props)`);
          fileInput.value = '';
          fetchConfig();
          fetchState();
        } else {
          showToast(data.error || 'Erreur lors de l\'import', true);
        }
      } catch (err) {
        showToast('Erreur: ' + err.message, true);
      } finally {
        progress.style.display = 'none';
        btn.disabled = false;
      }
    }

    // ─────────────────────────────────────────────────────────
    // Stats
    // ─────────────────────────────────────────────────────────

    function fmtMs(ms) {
      if (ms == null) return '-';
      const totalSec = Math.round(ms / 1000);
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }

    async function fetchStats() {
      try {
        const [statsRes, sessionsRes] = await Promise.all([
          fetch('/api/stats'),
          fetch('/api/sessions')
        ]);
        const stats = await statsRes.json();
        const sessions = await sessionsRes.json();

        // Summary cards
        document.getElementById('statTotal').textContent = stats.summary.totalSessions;
        document.getElementById('statWinRate').textContent = stats.summary.totalSessions > 0 ? stats.summary.winRate + '%' : '-';
        document.getElementById('statAvgTime').textContent = fmtMs(stats.summary.avgDurationMs);
        document.getElementById('statAvgHints').textContent = stats.summary.avgHints;

        // Prop stats table
        const propEntries = Object.values(stats.propStats || {});
        const propCard = document.getElementById('propStatsCard');
        if (propEntries.length > 0) {
          propCard.style.display = 'block';
          const tbody = document.getElementById('propStatsBody');
          tbody.innerHTML = propEntries.map(p => `
            <tr style="border-bottom: 1px solid #2a2a2a;">
              <td style="padding: 6px 8px; color: #eee;">${p.name}</td>
              <td style="text-align: center; padding: 6px 8px; color: ${p.solveRate >= 80 ? '#22c55e' : p.solveRate >= 50 ? '#f59e0b' : '#ef4444'};">${p.solveRate}%</td>
              <td style="text-align: center; padding: 6px 8px; color: ${p.overrideRate > 20 ? '#f59e0b' : '#888'};">${p.overrideRate}%</td>
              <td style="text-align: center; padding: 6px 8px; color: #ccc;">${fmtMs(p.avgSolveTimeMs)}</td>
              <td style="text-align: center; padding: 6px 8px; color: #22c55e;">${fmtMs(p.fastestSolveTimeMs)}</td>
              <td style="text-align: center; padding: 6px 8px; color: #ef4444;">${fmtMs(p.slowestSolveTimeMs)}</td>
              <td style="text-align: center; padding: 6px 8px; color: #888;">${p.sessionsWithData}</td>
            </tr>
          `).join('');
        }

        // Session list
        if (sessions.length > 0) {
          document.getElementById('sessionListCard').style.display = 'block';
          const container = document.getElementById('sessionListAdmin');
          // Show last 50, most recent first
          const sorted = [...sessions].sort((a, b) => (b.startedAt || 0) - (a.startedAt || 0)).slice(0, 50);
          container.innerHTML = sorted.map(s => {
            const icon = s.result === 'victory' ? '&#x1F3C6;' : '&#x1F480;';
            const date = s.startedAt ? new Date(s.startedAt).toLocaleString('fr-FR', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }) : '-';
            const duration = fmtMs(s.realDurationMs);
            const hints = s.hintsGiven || 0;
            const comments = s.comments ? `<div style="font-size: 11px; color: #888; margin-top: 4px; font-style: italic;">${s.comments}</div>` : '';
            return `<div style="padding: 8px 0; border-bottom: 1px solid #2a2a2a; font-size: 13px;">
              <span>${icon}</span>
              <span style="color: #ccc; margin-left: 6px;">${date}</span>
              <span style="color: #00d4ff; margin-left: 12px;">${duration}</span>
              <span style="color: #a78bfa; margin-left: 12px;">${hints} indice${hints !== 1 ? 's' : ''}</span>
              ${comments}
            </div>`;
          }).join('');
        }
      } catch (err) {
        console.error('Failed to fetch stats:', err);
      }
    }

    // ─────────────────────────────────────────────────────────
    // Init
    // ─────────────────────────────────────────────────────────

    fetchConfig();
    fetchState();
    fetchStats();
    setInterval(fetchState, 5000); // Poll state every 5s
  </script>
</body>
</html>
